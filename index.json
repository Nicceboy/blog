[{"content":"Since the release of Apple\u0026rsquo;s M1 Chips, ARM architecture has expanded to a larger user base. The power efficiency and performance of the new chips have made them quite desirable. Unfortunately, most of the existing advanced developer-required toolchains were for x86_64 architecture in many cases.\nThis blog post introduces a brief overview of how to set up a container runner on your ARM Macbook and how to create an AArch64 Open Container Initiative (OCI) container image from the scratch.\nThe example builds $\\rm\\TeX$ Live for $\\rm\\LaTeX$ since I could not find an existing up-to-date image after I sold my soul to the devil by getting M2 Apple device.\nThere might be (there are) simpler ways to build LaTeX documents on your Macbook, but this gives us the most control in a reproducible environment!\nSelecting a container runner There are already quite many options to run OCI containers on ARM and MacOS. The obvious choice would be Docker Desktop on Mac, but we might not want yet-another Chromium instance to consume battery. We also like open-source software.\nAll of the current options are QEMU based since containers are based on the Linux kernel:\nColima as a minimal CLI-based daemon (containerd/dockerd) with Lima Finch is AWS backed and aims to bring a native client on MacOS for nerdctl and containerd with Lima. Includes core features and there is development to do. Podman (No daemon, based on libpod) Podman Desktop (GUI, no daemon, based on libpod) Rancher (GUI, containerd/dockerd and Lima) As noted, regardless of the selection, we need a VM instance to run our Linux kernel.\nAs daemonless and rootless option, in this blog, we use Buildah to build our images, and Podman to run them.\nPodman and Buildah Podman can be installed by using Homebrew or Nix. Podman can build OCI images from the Dockerfile. There is an advanced tool called Buildah, but unfortunately, Buildah cannot be directly used, as it is for Linux only. Some of the features will work on MacOS (if installed with Nix), but not all of them, and images will be separated from the Podman VM.\nPodman build command uses a subset of Buildah and it is sufficient for our needs for now; podman build is equivalent to buildah build -f Dockerfile Buildah can be used from the VM or inside another container, but that is too complicated for this post.\nInstalling Podman on Mac We will use Nix to install QEMU and Podman.\nnix-env -iA nixpkgs.qemu nixpkgs.podman Before anything works, we need to set up a virtual machine. At this point, it is important to note that you cannot mount folders into the containers unless you mount them into the VM too. So double mount is required; mount the folder into the VM, and mount the folder from VM into the container.\nYou could either mount a specific limited directory into the machine or the whole home directory, for example. Mounting the whole home directory might not be advised, but I will do it for demonstration purposes. CPU count and memory size has been also increased.\npodman machine init -m 4096 --cpus 2 -v \u0026#34;$HOME:$HOME\u0026#34; podman machine start podman info The final command should showcase that we are indeed running CoreOS on ARM instructions inside a VM:\nhost: arch: arm64 buildahVersion: 1.28.0 cgroupControllers: - cpu - io - memory - pids . . distribution: distribution: fedora variant: coreos version: \u0026#34;37\u0026#34; . . . Creating Arch Linux image from scratch Arch Linux has an excellent wiki and collection of up-to-date packages. For that reason, we install LaTeX on that distribution. However, there is no official container image for ARM-based Arch Linux.\nWe can create a base image from the scratch; we download the official AArch64 multiplatform release, and since Linux is purely a file-based system, we just import the contents into the container, and it should work.\ncurl -L http://os.archlinuxarm.org/os/ArchLinuxARM-aarch64-latest.tar.gz | podman import - archlinuxarm This will create a new image with the namespace localhost/archlinuxarm:latest.\nYou can try it out\npodman run --rm -it archlinuxarm bash $\\rm\\TeX$ Live image The constant change of indexes is a problem with the use of Arch Linux in containers. If the container base is not updated for a while, there will be conflicts. The release of packages requires PGP signatures, and new authors will bring new keys. Sometimes keys change or deprecate, too. The following image takes this into account and should be able to update its keyring automatically. For security reasons, this is often recommended to do manually, but we will trust Arch Linux maintainers and supply chain for now.\nSince we are going to build documents, the correct time might be important. We will make it possible to guarantee the correct timezone.\nWe might also want to install additional CTAN packages, which are not included in the Arch Linux repository. For that, we need The TeXLive Package Manager (tlmgr), which is often challenging to install. The following example installs EB Garamond font and setspace package.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 FROM archlinuxarm:latest # If you want to use custom mirror to download packages instead of the automatic geolocation # COPY mirrorlist /etc/pacman.d/mirrorlist # Define timezone for container ENV TZ=Europe/Helsinki RUN ln -snf \u0026#34;/usr/share/zoneinfo/$TZ\u0026#34; /etc/localtime \u0026amp;\u0026amp; \\ echo \u0026#34;$TZ\u0026#34; \u0026gt; /etc/timezone \u0026amp;\u0026amp; \\ # If you are using BuildKIt instead of Buildah, see https://github.com/moby/buildkit/issues/1267 \\ # sed -i -e \u0026#39;s~#IgnorePkg.*~IgnorePkg = filesystem~g\u0026#39; \u0026#39;/etc/pacman.conf\u0026#39; \u0026amp;\u0026amp; \\ # /etc/hosts and /etc/resolv.conf are read-only, filesystem package attempts to modify them pacman-key --init \u0026amp;\u0026amp; pacman-key --populate archlinuxarm \u0026amp;\u0026amp; \\ pacman-key --refresh-keys \u0026amp;\u0026amp; \\ yes | pacman -Sy --noconfirm archlinux-keyring \u0026amp;\u0026amp; \\ yes | pacman -Syyu --noconfirm \u0026amp;\u0026amp; \\ pacman -S --noconfirm texlive-most \\ zsh \\ grml-zsh-config \\ wget \\ vim \\ # Reduce image size \\ \u0026amp;\u0026amp; pacman -Sc --noconfirm \u0026amp;\u0026amp; \\ rm -rf /var/cache/pacman/pkg/ \\ \u0026amp;\u0026amp; usermod --shell /bin/zsh alarm ENV TLMGR /usr/share/texmf-dist/scripts/texlive/tlmgr.pl # For some reason, default tlmgr.pl contex filepath is in wrong location in Arch Linux RUN sed -i \u0026#39;/\\$Master = \u0026#34;\\$Master\\/\\.\\.\\/\\.\\.\u0026#34;;/c \\$Master = \u0026#34;\\${Master}\\/\\.\\.\\/\\.\\.\\/\\.\\.\u0026#34;;\u0026#39; $TLMGR USER alarm WORKDIR /home/alarm RUN echo \u0026#34;alias tlmgr=\u0026#39;${TLMGR} --usermode\u0026#39;\u0026#34; \u0026gt;\u0026gt; /home/alarm/.zshrc \u0026amp;\u0026amp; \\ ${TLMGR} --usermode -v init-usertree \u0026amp;\u0026amp; ${TLMGR} --usermode install ebgaramond setspace ENTRYPOINT [\u0026#34;/bin/zsh\u0026#34;] Generated image will have the latest TeX Live distribution with a working package manager and desired default timezone. On runtime, the timezone can also be changed to -e TZ=Europe/Amsterdam with Podman parameter.\nIEEE Conference template as an example As an example, we will build IEEE Conference template. The template is provided in here.\nDownload and extract it:\ncurl -o ieee_template.zip -L https://www.ieee.org/content/dam/ieee-org/ieee/web/org/pubs/conference-latex-template_10-17-19.zip \u0026amp;\u0026amp; 7z x ieee_template.zip Mount the source into our container. Note the --userns option; it maps the ownership of the volume inside the container to the correct non-root user.\ncd Conference-LaTeX-template_10-17-19 podman run --userns=keep-id:uid=1000,gid=1000 --rm -itv \u0026#34;$(pwd):/latex\u0026#34; texlive:latest To build our document with LuaLatex and to also detect new changes\ncd /latex latexmk -pdflatex=lualatex -pdf -pvc conference_101719.tex And the PDF will finally appear in the mounted folder and will be rebuilt if the source is changed.\nConclusion Using Podman to build PDF files might be overly complicated, but it gives us a working and reproducible environment. LaTeX can be messy sometimes, and it is good to have a chance to roll back to the previous working environment version, which can be quickly removed as well.\n","permalink":"https://nicce.dev/posts/latex-with-containers-and-apple-silicon/","summary":"This blog post introduces a brief overview of how to set up a container runner on your ARM Macbook and how to create an AArch64 Open Container Initiative (OCI) container image from the scratch.","title":"LaTeX with OCI containers, Podman and Arch Linux ARM on Apple Silicon"},{"content":"There was a moment in one weekend when I wanted to play one Windows game on my laptop, but unfortunately, I am using Linux with integrated Intel graphics and that does not sound too promising.\nThe other repelling thought proved to be the amount of dependencies I would need that I am able to play this game on Wine. I would like to maintain my system as whole and get rid of unnecessary stuff later on, somewhat easily. Virtualization is not option, as I have already weak performance.\nHowever, there is another, bit more lightweight solution; containers, especially OCI or Docker containers. So instead of playing the game a bit, I ended up spending a weekend for installing it. In the end, it seemed to be possible. On top of wrapping all the software on single container, games are executed at least in a bit more isolated matter. If I ever want to get same environment back again, I could just pull single Docker image.\n{{ /* \u0026lt; figure src=\u0026quot;/images/preview_mtg_container.png\u0026quot; title=\u0026ldquo;Magic The Gathering: Arena works well when played from the Linux container\u0026rdquo; alt=\u0026ldquo;Testing MTGArena on container.\u0026rdquo; */ \u0026gt;}}\nThis article expects, that you are already familiar with containers.\nGitHub repository with source code is available here.\nChallenges Traditional container applications are in the most of the cases CLI based, not making sound and rarely needing hardware acceleration or GPUs. This brings more requirements for containers, when we are talking about games:\nSound support\nDisplay support\nGPU/Hardware acceleration\nWhat this means in practice, is that container needs more access into host system resources and applications.\nSound PulseAudio is one of the most used sound servers in the Linux world for generic purpose. It is probably already on your machine. Jack is used more for professionals and left out of scope. PipeWire might be the future.\nIf you don’t have it already, for Debian you can install it for example with following command. It might be better to skip this, if you don’t know how to make it as your primary server if you have another one already.\napt-get update \u0026amp;\u0026amp; apt-get install pulseaudio\nTo get some sound from the container for your host machine speakers, one way is to grant access for PulseAudio server running on your host machine. To achieve this, PulseAudio must be configured to provide accessible Unix socket.\nLook for user-specific Pulse configuration file in path:\ncat \u0026quot;${HOME}/.config/pulse/default.pa\u0026quot;\nModify or create the file with following contents:\n.include /etc/pulse/default.pa load-module module-native-protocol-unix socket=/tmp/pulse-socket After applying changes, server should be restarted:\npulseaudio -k pulseaudio --start pulseaudio --check Now, when we have also container with PulseAudio installed, we can share this socket as read-only volume into container. To make container to use this socket, it should be configured as well; modify file in the same path as before inside container to contain:\n# Use host socket default-server = unix:/tmp/pulse-socket enable-shm = false # Prevent container from running server autospawn = no daemon-binary = /bin/true # Returns true but does nothing However, Pulse server requires authentication, and this is applied with magic cookies, if we are not granting anonymous access. Anonymous access can be allowed by adding auth-anonymous=1 just before socket definition on host configuration file.\nNon-anonymous access requires copying the cookies each time container is executed from the host path “${HOME}/.config/pulse/cookie” into same destination path in container. Sounds should be working now.\nDisplay There are two main display servers; X.org and Wayland. X.org is beginning to reach its end of life, but still most of the applications are only supporting it.\nTo make X applications to work under containers, we need to share Unix socket as read-only volume again, this time in the path /tmp/.X11-unix .\nAdditionally, environment value of $DISPLAY must be shared into container, to tell location of the display.\nIn general, granting access to host machine’s X server is considered dangerous, as content and key presses can be manipulated and seen. X11docker project attempts to solve some of these problems.\nWe can limit access for this specific container with similar way than with sound; copying magic cookies into container when it is executed.\nHexadecimal key can be acquired with xauth tool:\nxauth list workstation/unix: MIT-MAGIC-COOKIE-1 f57d6fbab111c34b56efb04776e52229 Inside container as root, display can be then added as:\nxauth add “$DISPLAY” . \u0026lt;key\u0026gt;\nThis will generate .Xauthority file, which should be copied for correct user as well. Note, that variables have been predefined manually.\ncp /root/.Xauthority \u0026#34;${USER_HOME}\u0026#34; chown \u0026#34;${USER_UID}\u0026#34;:\u0026#34;${USER_GID}\u0026#34; \u0026#34;${USER_HOME}/.Xauthority\u0026#34; NOTE: When running XWayland compositor (Wayland support for X), it seems that UID of Docker user in container must be same than in the owner of host X server. Otherwise there are not enough permissions. This has impact for the level of isolation.\nPure Wayland applications are yet to be tested, but should not take much more effort.\nGraphic cards and hardware acceleration There was a time when this sounded complicated problem for me, but it was simple after all.\nAll what you need to do, is to share graphic cards as devices, and install drivers!\nGraphic cards are usually found from the path /dev/dri . They can be passed as devices into container. To install drivers, you must find suitable packages.\nOn Debian based system, you can install AMD and Intel based drivers with Vulkan support by getting following packages:\ndpkg --add-architecture i386 \u0026amp;\u0026amp; \\ # Get 32-bit support as well apt-get update \u0026amp;\u0026amp; apt-get install vulkan-utils \\ mesa-vulkan-drivers \\ mesa-vulkan-drivers:i386 \\ libvulkan1 \\ libvulkan1:i386 \\ libglx-mesa0 \\ libgl1-mesa-dri Vulkan is required to boost performance especially of DirectX 11 applications, when running Windows games in Wine. There is project called as dxvk which attempts to make transitions from DirectX into Vulkan.\nIf everything is good in you container, running command vulkaninfo should tell information about your graphic card. With command vkcube you should get spinning 3D cube.\nManaging games and runners on Linux There is one big open-source project just for this; Lutris is trying to simplify it all. I decided to try it for managing Wine and dxvk runner versions and for managing game installations. It was installed into container as well.\nDependencies of Lutris can be installed for Debian based system as follows:\necho \u0026#34;deb http://download.opensuse.org/repositories/home:/strycore/Debian_10/ ./\u0026#34; | tee /etc/apt/sources.list.d/lutris.list \\ \u0026amp;\u0026amp; wget -q https://download.opensuse.org/repositories/home:/strycore/Debian_10/Release.key -O- | apt-key add - \\ \u0026amp;\u0026amp; apt-get update \\ \u0026amp;\u0026amp; apt-get -y install lutris Latest client can be installed from GitHub releases:\nmkdir -p /tmp/lutris \u0026amp;\u0026amp; \\ curl -s https://api.github.com/repos/lutris/lutris/releases/latest \u0026gt; /tmp/lutris/version.json \u0026amp;\u0026amp; \\ jq \u0026#34;.tarball_url\u0026#34; /tmp/lutris/version.json | xargs curl -Lo /tmp/lutris/lutris \u0026amp;\u0026amp; \\ mkdir -p /opt/lutris \u0026amp;\u0026amp; \\ tar -C /opt/lutris --strip-components 1 -xf /tmp/lutris/lutris \u0026amp;\u0026amp; \\ rm -rf /tmp/lutris Client will end up into path /opt/lutris/bin/lutris .\nAll additional data will be installed into container’s user home directory. To make is sustainable after stopping containers, it is mounted as named volume into host system. Environment and all the packages can change, but this data can be saved even if deleting all Docker images and containers.\nThe one specific game I wanted to play was Magic The Gathering: Arena. There is pre-made installation script in Lutris already, which installs some dependencies game is requiring, such as .NET Framework 4.8.\nGame has been running smoothly on my machine so far, with Vulkan transitions after little tweaking of dxvk versions. However, functionality of other games depends heavily on sufficient Wine features.\nConclusion In the end, I made Python script and specific Docker image to automate most of the requirements and it is available at GitHub in here. It will create required named volume of game data ($HOME directory of user) and sets environment up. Docker image has been pre-built and can be pulled with command\ndocker pull ghcr.io/nicceboy/lutris-vulkan:latest\nPython script will launch the Lutris client from container after setting up environment. As manual step, PulseAudio should be configured beforehand.\nScript can be installed as package as\npip install git+https://github.com/Nicceboy/gamify-containers\nLutris can be finally started\nplaylutris --detach\nAt this point, I had already installed the game before, and game data is visible from mounted volume.\nIn my case, I did not make any performance measurements to see impact from container usage. Game was still very playable and therefore I did not bother with that.\n","permalink":"https://nicce.dev/posts/running-your-favorite-windows-games-on-linux-containers/","summary":"There was a moment in one weekend when I wanted to play one Windows game on my laptop, but unfortunately, I am using Linux with integrated Intel graphics and that does not sound too promising.\nThe other repelling thought proved to be the amount of dependencies I would need that I am able to play this game on Wine. I would like to maintain my system as whole and get rid of unnecessary stuff later on, somewhat easily.","title":"Running Your Favorite Windows Games on Linux Containers"},{"content":"Work in progress\u0026hellip;\n","permalink":"https://nicce.dev/about/","summary":"Things about me.","title":"About"}]